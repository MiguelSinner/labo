#Histograma
hist(resist, breaks=limite,main="Histograma de la variable Resistencia",col="cyan",
xlab="intervalos", ylab="frecuencia")
# Definimos vector de extremos
R=c(122,124,126,128,130,132,134,136,138,140,142,144,146,148)
resist_1 <-cut(resist,breaks=R)
resist_1
table(resist_1)
# Histograma
hist(resist, breaks = R, main = "Histograma de la variable Resistencia", col = "cyan", xlab = "Intervalos", ylab = "Frecuencia")
#cargamos los datos
salud <- read_excel("Datos.xlsx", sheet="salud")
#cargamos los datos
salud <- read_excel("Datos.xlsx", sheet="salud")
head(salud)
as.data.frame(salud)
#cargamos los datos
salud <- read_excel("Datos.xlsx", sheet="salud")
as.data.frame(salud)
#cargamos los datos
salud <- read_excel("Datos.xlsx", sheet="salud")
as.data.frame(salud)
#cargamos los datos
salud <- read_excel("Datos.xlsx", sheet="salud")
as.data.frame(salud)
table(salud)
glimpe(salud)
glimpse(salud)
#definimos la variable de estudio
Salud <-factor(salud$Problemas)
salud
#definimos la variable de estudio
Salud <-factor(salud$Problemas)
salud
library(dplyr)
glimpse(salud)
#definimos la variable de estudio
Salud <-factor(salud$Problemas)
salud
#definimos la variable de estudio
Salud <-factor(salud$Problemas)
Salud
knitr::opts_chunk$set(echo = TRUE)
jugo <- c(21.60,19.72,18.92,23.01,17.98,22.06,25.01,21.98,20.80)
jugo
# Tamaño de muestra
n = 9
# Estadísticos
summary(jugo)
# Promedio
x <- mean(jugo)
x
# Desviación estándar
s <- sd(jugo)
s
# Calculo del intervalo de confianza para la media 90%
t.test(jugo,conf.level = 0.90,alternative = "two.sided")$conf.int
# Calculo del intervalo de confianza para la media 90%
t.test(jugo,conf.level = 0.90)$conf.int
setwd("~/")
knitr::opts_chunk$set(echo = TRUE)
hist(mtcars$mpg, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,35), ylim=c(0,16))
hist(MPGdesplazado, add=TRUE,col=rgb(0,0,1,alpha=0.75))
iris
hist(iris$Sepal.Length)
hist(iris$Petal.Length)
MPGdesplazado=(mtcars$mpg-5)*0.9
hist(mtcars$mpg, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,35), ylim=c(0,16))
hist(MPGdesplazado, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,35), ylim=c(0,16))
hist(iris$Petal.Length, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,10), ylim=c(0,5))
hist(iris$Petal.Length, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,10), ylim=c(0,9))
hist(iris$Petal.Length, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,10), ylim=c(1))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,10), ylim=c(0,9))
hist(iris$Petal.Length, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
hist(iris$Sepal.Length, col="forestgreen",xlab="mpg",main =
"MPG del archivo MTCARS", ylab = "Frecuencia", xlim=c(0,10))
hist(iris$Petal.Length, add=TRUE,col=rgb(0,0,1,alpha=0.75))
legend("topright",36,bty="n",c("MPG","MPGdesplazado"),fill=c("forestgreen","blue"))
virginica = iris[iris$Species="virginica"]
virginica = iris[iris$Species="versicolor"]
head(iris)
virginica = iris[iris$Species="setosa"]
virginica = filter(iris, Species = "virginica")
virginica = filter(iris, Species = virginica)
virginica = filter(iris, Species %in% c("virginica")
virginica
v1 = filter(iris, Species %in% c("virginica")
v1
v1 = filter(iris, Species %in% c("virginica")
head(v1)
virginica = filter(iris, Species == "virginica")
virginica = filter(iris, iris$Species == "virginica")
virginica
virginica = iris(iris, iris$Species == "virginica")
virginica = iris(iris, iris$Species == "virginica")
virginica = iris[iris, iris$Species == "virginica"]
virginica = iris[iris, iris$Species == "virginica", Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Sepcies]
virginica = iris[iris, iris$Species == "virginica", "Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width", "Sepcies"]
virginica = iris[iris, iris$Species == "virginica", column=c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width", "Sepcies")]
virginica = iris[iris, iris$Species == "virginica", columns=c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width", "Sepcies")]
virginica = iris[iris, iris$Species == "virginica", ]
virginica = iris[iris$Species == "virginica", ]
virginica
virginica = iris[iris$Species == "virginica", ]
virginica
setosa = iris[iris$Species == "setosa", ]
setosa
versicolor = iris[iris$Species == "versicolor", ]
versicolor
hist(virginica)
hist(virginica$Sepal.Length)
setwd("~/")
setwd("~/")
knitr::opts_chunk$set(echo = TRUE)
rep(1,2, time=3)
rep(1:2, time=3)
rep(1:3, time=3)
rep(1:3, time=3, seq(0.5))
rep(1:3, time=3, seq(0.5))
x <- seq(1,3, by=0,5)
x <- seq(1,3, by=0.5)
x <- seq(1,3, by=0.5)
x
rep(x, times=3)
rep(1:2, each=3)
rep(1:3, each=3)
sort(x)
rev(x)
table(x)
x[c(1,5)]
x
x=c(1,2,3,10,5,6,7,10,8)
x[x==10]
x[x>10]
log(e)
log(exp(1))
15:10
m <- c(t,f,f,t)
m <- c(t,f,f,t)
m <- c(T,F,F,T)
p <- c(T,F,T,F)
m|p
h <- paste(c("a","b"), 2:5, sep="")
h <- paste(c("a","b"), 2:5, sep="")
h
t <- paste(c("a","b"), 2:5, sep=",")
t <- paste(c("a","b"), 2:5, sep=",")
t
t <- paste(c("a","b"), 2:5, sep=",")
t
length(t)
length(h)
h <- paste(c("a","b"), 2:5, sep="")
h
length(h)
trunc(-pi)
floor(pi)
trunc(-pi)
floor(-pi)
trunc(-pi)
floor(-pi)
ceiling(-pi)
g <- c(2,3,1)
order(g)
g <- c("frio","tibio","caliente")
order(g)
g <- c("frio","tibio","caliente")
order(g)
g <- c("cliente","tibio","frio")
order(g)
v1 <- c(1,2,3)
v2 <- c(4,5,6)
sum(v1*v2)
v1%%v2
v1*v2
v1*v2
knitr::opts_chunk$set(echo = TRUE)
setwd("~/")
##Cargamos las librerías
library(readxl)
library(readxl)
setwd("C:\Users\Migue\Desktop\Facultad Migue\Maestría en Minería de Datos\Análisis Inteligente de Datos\2022 03 08") # fija la ruta de la carpeta donde se encuentran los archivos con los que se va a trabajar y donde se guardarán las salidas que se ejecuten
getwd() # devuelve la ruta de la carpeta de trabajo
##Operaciones básicos
2+6 # suma
3*4 # producto
-4/(5-3) # cociente
sqrt(9) # raíz cuadrada
sqrt(9) # raíz cuadrada
cos(pi) # funciones trigonométricas
exp(-2) # función exponencial
factorial(5) # devuelve el factorial de un número
IMCinfantil <- read_excel("IMCinfantil.xlsx")
##Leemos los datos
IMCinfantil <- read_excel("C:\Users\Migue\Desktop\Facultad Migue\Maestría en Minería de Datos\Análisis Inteligente de Datos\2022 03 08")
##Leemos los datos
IMCinfantil <- read_excel("C:\Users\Migue\Desktop\Facultad Migue\Maestría en Minería de Datos\Análisis Inteligente de Datos\2022 03 08\IMCinfantil")
##Leemos los datos
IMCinfantil <- read_excel("C:/Users/Migue/Desktop/Facultad Migue/Maestría en Minería de Datos/Análisis Inteligente de Datos/2022 03 08IMCinfantil.xlsx")
##Leemos los datos
IMCinfantil <- read_excel("C:/Users/Migue/Desktop/Facultad Migue/Maestría en Minería de Datos/Análisis Inteligente de Datos/2022 03 08/IMCinfantil.xlsx")
##Operaciones básicos
2+6 # suma
3*4 # producto
-4/(5-3) # cociente
4^0.2 # potencia
sqrt(9) # raíz cuadrada
cos(pi) # funciones trigonométricas
exp(-2) # función exponencial
factorial(5) # devuelve el factorial de un número
# asignación de un valor a una variable
a=log(3)
a<-log(3) # es equivalente al anterior
log(3)->a # es equivalente al anterior
b=log10(0.1) # asignación de un valor a la variable b
c=a*(1-b) # operación entre variables
a # devuelve el valor guardado en a
b # devuelve el valor guardado en a
c # devuelve el valor guardado en a
##secuencias de números
1:5 # números del 1 al 5 orden creciente
2:100 # números del 2 al 100 orden creciente
15:10 # números del 15 al 10 orden decreciente
a=1:5 # reemplaza lo guardado en la variable a
a # devuelve el valor guardado en a
x <- c(1,2,3,4,5,6,7,8) # devuelve los enteros de 1 a 6
x
x <- 1:8 # es equivalente al anterior
x
assign("x", 1:8) # otra manera de asignar valores a un vector
x
x <- seq(1,8) # es equivalente al anterior
x
x1=8:1
x1
y=seq(1,4,0.2) # devuelve los números de 1 a 4 espaciados en 0.2
y
z=rep(1,5) # repite el 1 cinco veces
z
w=rep(1:3,4) # repite del 1 al 3 cuatro veces
w
q=rep(c(1,3,7),2) # repite la concatenación dos veces
q
###valores lógicos
m <- c(T,F,F,T) # concatena lo pedido
m
n <- rep(c(T,F),3) # repite la concatenación tres veces
n
l=w>2 # asigna una proposición a la variable l
w
l # asigna valor de verdad de la proposición
p<-c(T,F,T,F)
p
m&p # devuelve la conjunción entre componentes de vectores lógicos de igual longitud
m|p # devuelve la disyunción entre componentes de vectores lógicos de igual longitud
!m # devuelve la negación de cada componente
w[2:4] # davuelve las componentes de 2 a 4 del vector w
w
w[c(1,4,6)] # devuelve las componentes 1, 4 y 6 del vector w
w[-c(1,4,6)] # devuelve el vector w sin las componentes 1, 4 y 6
rep(c(T,T,F,F),3)
w[rep(c(T,T,F,F),3)] # devuelve las componentes de w que corresponden con TRUE
w
rep(c(T,T,F,F),3)
!rep(c(T,T,F,F),3) # ! niega en forma lógica
w[!rep(c(T,T,F,F),3)] # devuelve las componentes de w que corresponde
u=c(3,8,2,7,3,2,1)
u==3  # operación lógica que busca las posiciones de u que guardan el 3
u[u==3]<-4 # en esas posiciones asigna un 4
u
which(u>=4) # devuelve las posiciones de u que tienen números mayores o iguales a 4
which(u>=4) # devuelve las posiciones de u que tienen números mayores o iguales a 4
u[which(u>=4)]<-0 # asigna 0 a esas posiciones
u
h<-c(2,7,4)
names(h) # consulta los nombres de las componentes del vector h
names(h)<-c("Alicia", "Pedro", "Lucas") # asigna nombres a las componentes de h
h # verifica la asignación
h["Alicia"] # devuelve la componente según el nombre
f<-"Usted está aprendiendo rápidamente" # asigna un vector de caracteres de longitud 1
f
g<-c("caliente", "tibio", "frío") # asigna un vector de caracteres de longitud 3
h <- paste(c("a","b"), 2:5, sep="") # genera pares ordenados
h
t=paste(c("a","b"), 2:5, sep=",") # genera pares ordenados separados por comas
t
length(w) # devuelve la longitud del vector w
length(g) # devuelve la longitud del vector g
length(c(w,g)) # devuelve la longitud del vector w concatenado con g
mode(w) # devuelve el tipo de datos del vector w, en este caso numérico
mode(g) # devuelve el tipo de datos del vector g, en este caso de caracteres
mode(m) # devuelve el tipo de datos del vector m, en este caso lógico
storage.mode(y) # equivalente a mode, en este caso el tipo es "double" que significa de doble precisión
storage.mode(w) # en este caso el tipo es entero
storage.mode(g)
storage.mode(m)
##Ordenamiento de Vectores
n=c(2,1,-8,3)
n
g
g[c(2, 3, 1)] # cambia el orden en las componenetes
sort(g) # ordena alfabéticamente las componentes del vector de caracteres
rev(g) # invierte el orden de las componentes del vector
order(g) # devuelve la posición de las componentes del vector en el orden alfabético
g[order(g)] # equivalente a sort
q=rep(c(1,3,7),2)
q
unique(q) # devuelve las cifras que aparecen omitiendo repeticiones
duplicated(q) # indica cifras repetidas
v1<-rep(2,4) #definimos el vector1
v1
v2<-2:5  # definimos el vector 2
v2
-2*v2
v2+3
v1+3*v2
v1/v2
v1*v2
v1**v2
v3=2*v1-3*v2
v3
min(v3) # devuelve el valor mínimo del vector
max(v3) # devuelve el valor máximo del vector
sum(v3) # suma las componentes del vector
umsum(v3) # devuelve un vector que guarda en cada componente la suma de las anteriores más ésa
prod(v3) # multiplica las componentes de un vector
sum(v1*v2) # producto escalar de dos vectores
v1%*%v2    # producto escalar de dos vectores
ls() # lista todas las variables que se han creado en el espacio de trabajo
data=1:10
matrix(data,nrow=2,ncol=5) # acomoda los datos por columna en una matriz de nrow filas y ncol columnas
matrix(c(2,4,5,6,-8,11),nrow=2)  # acomoda la concatenación por columnas de acuerdo a la cantidad de filas indicada
matrix(data,nrow=2,ncol=5,byrow=T)  # # acomoda los datos por fila en una matriz de nrow filas y ncol columnas
matrix(c(2,4,5,6,-8,11),nrow=2)  # acomoda la concatenación por columnas de acuerdo a la cantidad de filas indicada
vec1=seq(2,5)   # asigna valores a un vector
vec2=seq(-5,-2) # asigna valores a otro vector
vec1
vec2
cbind(vec1,vec2)  # devuelve la matriz que tiene a estos vectores como columnas
rbind(vec1,vec2)  # devuelve laa matriz que tiene a estos vectores como filas
mat1=matrix(data,nrow=2,ncol=5) # asigna valores a una matriz
mat1
colnames(mat1)<-c("A","B","C","D","E") # asigna nombres a las columnas de la matriz
mat1 # devuelve la matriz, ahora con nombres en sus columnas
rownames(mat1)<-c("2015","2016") # asigna nombres a las filas de la matriz
mat1 # devuelve la matriz, ahora con nombres en sus filas
###Dimensiones y modo de almacenamiento de matrices
dim(mat1) # devuelve la cantidad de filas y de columnas de la matriz
storage.mode(mat1) # devuelve el tipo de valores guardados en la matriz
##Acceso a los elementos de una matriz
mat1[1,2] # devuelve el elemento de la fila 1 y la columna 2 de la matriz
mat1[1,3:5] # devuelve los elementos de la fila 1 y correspondientes a las columnas de 3 a 5
mat1[1,] # devuelve la fila 1 de la matriz
mat1[,2] # devuelve la columna 2 de la matriz
mat1[1,2]<--3.1 # asigna un valor dado en la fila 1 y la columna 2 de la matriz
mat1
storage.mode(mat1) # observar que cambió el modo de almacenamiento de la matriz
mat2 # devuelve la matriz
t(mat2) # devuelve la matriz traspuesta de la matriz
##Operaciones con matrices
mat2<-matrix(seq(10,1),nrow=2,byrow=T) # asigna valores a una nueva matriz
mat2 # devuelve la matriz
t(mat2) # devuelve la matriz traspuesta de la matriz
mat1
mat1+mat2 # suma de matrices
3*mat2 # producto de matriz por escalar
mat1-mat2 # resta de matrices
mat1*mat2 # producto elemento a elemento
sqrt(mat2) # raíz cuadrada de cada elemento de la matriz
sqrt(mat1) # observar que cuando la operación no está definida devuelve NaN
sqrt(-9) # no está definido
sqrt(-9+0i) # lo trata como número complejo
exp(mat2) # exponencial a cada elemento de la matriz
log10(mat2) # logaritmo a cada elemento de la matriz
det(mat3) # devuelve el determinante de la matriz
mat3=mat1%*%t(mat2) # asigna a una matriz el producto matricial de dos matrices
mat3 # devuelve el resultado del producto matricial
det(mat3) # devuelve el determinante de la matriz
solve(mat3) # devuelve la matriz inversa de la matriz
1/det(mat3) # devuelve el inverso del determinante
diag(mat3) # devuelve la diagonal principal de la matriz
sum(diag(mat3)) # devuelve la traza de la matriz
eigen(mat3)$values  # devuelve los autovalores de la matriz
eigen(mat3) # devuelve los autovectores de la matriz
eigen(mat3)$vectors  # es equicvalente al anterior
mat1[1,2] # devuelve el elemento de la fila 1 y la columna 2 de la matriz
mat1[1,3:5] # devuelve los elementos de la fila 1 y correspondientes a las columnas de 3 a 5
mat1[1,] # devuelve la fila 1 de la matriz
mat1[,2] # devuelve la columna 2 de la matriz
mat1[1,2]<--3.1 # asigna un valor dado en la fila 1 y la columna 2 de la matriz
mat1
mat2<-matrix(seq(10,1),nrow=2,byrow=T) # asigna valores a una nueva matriz
mat2 # devuelve la matriz
t(mat2) # devuelve la matriz traspuesta de la matriz
mat1+mat2 # suma de matrices
mat1-mat2 # resta de matrices
mat2+3 # suma 3 a cada elemento de la matriz
3*mat2 # producto de matriz por escalar
mat1*mat2 # producto elemento a elemento
sqrt(mat2) # raíz cuadrada de cada elemento de la matriz
sqrt(mat1) # observar que cuando la operación no está definida devuelve NaN
sqrt(-9) # no está definido
sqrt(-9+0i) # lo trata como número complejo
exp(mat2) # exponencial a cada elemento de la matriz
log10(mat2) # logaritmo a cada elemento de la matriz
mat3=mat1%*%t(mat2) # asigna a una matriz el producto matricial de dos matrices
mat3 # devuelve el resultado del producto matricial
det(mat3) # devuelve el determinante de la matriz
solve(mat3) # devuelve la matriz inversa de la matriz
1/det(mat3) # devuelve el inverso del determinante
det(solve(mat3)) # devuelve el determinante de la matriz inversa inversa
mat3%*%solve(mat3) # devuelve el producto de una matriz por su inversa; es decir, la matriz identidad
library(readxl) ##Permite leer archivos xlsx
library(ggplot2) ##Paquete para confeccionar dibujos
library(ggrepel) ##Paquete que manipula etiquetas para gr�ficos
library(plotrix) ##Paquete para gr�ficos requerido para la libreria smacof
library(smacof)  ##Paquete para MDS basado en la minimizaci�n del stress
library(UsingR)
library(pgirmess)
library(MASS)
library(carData)
library(car)
library(caret)
library(exactRankTests)
library(HistData)
library(FactoMineR)
library(foreign)
library(psych)
library(knitr)
library(xtable)
library(dendextend)
library(Rcpp)
library(ggplot2)
library(ggfortify)
library(corrplot)
library(Stuff)
library(broom)
library(dendextendRcpp)
if (!require('devtools')) install.packages('devtools');
devtools::install_github('talgalili/dendextendRcpp')
library(dendextendRcpp)
library(dendextendRcpp)
library(Rcpp)
museo1<- hcut(autos, k = 5, stand = TRUE)
autos <- data.frame(read_excel("C:/Users/Migue/Desktop/Facultad Migue/Maestría en Minería de Datos/Análisis Inteligente de Datos/Examen Final/clasifautos.xlsx"))
autos
autos <- na.omit(autos)
autos = autos[,-1]
autos = autos[,-1]
autos = autos[,-3]
PCA.autos = PCA(autos[,c("venta", "reventa", "precio", "motor", "CV", "pisada", "ancho","largo",
"peso", "depóstito", "mpg")])
install.packages('Rcpp')
install.packages("Rcpp")
install.packages(Rcpp)
install.packages("Rcpp")
library(readxl) ##Permite leer archivos xlsx
library(ggplot2) ##Paquete para confeccionar dibujos
library(ggrepel) ##Paquete que manipula etiquetas para gr�ficos
library(plotrix) ##Paquete para gr�ficos requerido para la libreria smacof
library(smacof)  ##Paquete para MDS basado en la minimizaci�n del stress
library(UsingR)
library(pgirmess)
library(MASS)
library(carData)
library(car)
library(caret)
library(exactRankTests)
library(HistData)
library(Rcpp)
autos <- data.frame(read_excel("autos.xls"))
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ',
'devtools', 'uuid', 'digest'))
install.packages('IRkernel')
source("~/.active-rstudio-document")
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ',
'devtools', 'uuid', 'digest'))
install.packages(c("repr", "IRdisplay", "evaluate", "crayon", "pbdZMQ", "devtools", "uuid", "digest"))
install.packages('IRkernel')
install.packages( "data.table", dependencies= TRUE )
install.packages(c('Matrix', 'Hmisc', 'rlist', 'yaml', 'parallel',
'primes', 'bit64', 'IRdisplay', 'repr', 'vioplot', 'DT', 'ROCR', 'R.utils',
'Rcpp', 'devtools', 'ggplot2', 'gganimate', 'transformr', 'DiagrammeR',
'rpart', 'rpart.plot', 'treeClust', 'ranger', 'randomForest',
'xgboost', 'lightgbm', 'DiceKriging', 'mlrMBO'))
install.packages(c("Matrix", "Hmisc", "rlist", "yaml", "parallel", "primes", "bit64", "IRdisplay", "repr", "vioplot", "DT", "ROCR", "R.utils", "Rcpp", "devtools", "ggplot2", "gganimate", "transformr", "DiagrammeR", "rpart", "rpart.plot", "treeClust", "ranger", "randomForest", "xgboost", "lightgbm", "DiceKriging", "mlrMBO"))
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/411_ranger.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/411_ranger.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/RepensandoOverfitting/521_arbol_canaritos_prp.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/411_ranger.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/411_ranger.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/433_ranger_BO.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/433_ranger_BO.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/433_ranger_BO.r")
source("C:/Users/Migue/Desktop/Facultad Migue/Laboratorio1/labo/src/ranger/433_ranger_BO.r")
vignette(topic = "longintro", package = "rpart")
